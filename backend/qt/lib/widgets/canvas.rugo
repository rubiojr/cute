# Canvas widget for Cute
#
# Drawing surface using Qt's paintEvent system. Overrides paintEvent
# on a QWidget so the QPainter is created inside the event -- the
# idiomatic Qt6 approach.

require "../ctx" as "_ctx"
require "../props" as "_props"

# Canvas widget with redraw callback.
#
#   canvas({width: 320, height: 200}, fn(ctx, size, value)
#     ctx.fill("#11111b")
#     ctx.line(10, 10, size.width - 10, 10, "#89b4fa")
#   end)
#
# Returns QWidget handle.
def canvas(arg1 = nil, arg2 = nil)
  p = nil
  draw_fn = nil
  if type_of(arg1) == "Hash"
    p = arg1
    draw_fn = arg2
  else
    draw_fn = arg1
  end

  c = qt6.new_qwidget2()
  _props.apply(c, p)
  _ctx.add(c)

  if draw_fn != nil
    bound_state = nil
    if p != nil && p["state"] != nil
      bound_state = p["state"]
    end

    c.on_paint_event(fn(super, ev)
      super(ev)
      w = c.width()
      h = c.height()
      if w > 0 && h > 0
        state_value = nil
        if bound_state != nil
          state_value = bound_state.get()
        end
        painter = qt6.new_qpainter2(c.qpaint_device)
        ctx = _painter_ctx(painter, w, h)
        draw_fn(ctx, {width: w, height: h}, state_value)
        painter.delete()
      end
    end)

    if bound_state != nil
      bound_state.on(fn(v)
        c.update()
      end)
    end
  end

  return c
end

# -- Private helpers ----------------------------------------------------------

# Build a drawing context that wraps a live QPainter.
def _painter_ctx(painter, w, h)
  ctx = {}
  ctx["fill"] = fn(color)
    painter.fill_rect5(0, 0, w, h, qt6.new_qcolor6(color))
  end
  ctx["line"] = fn(x1, y1, x2, y2, color = nil)
    if color != nil
      painter.set_pen(qt6.new_qcolor6(color))
    end
    painter.draw_line2(x1, y1, x2, y2)
  end
  ctx["text"] = fn(x, y, value, color = nil)
    if color != nil
      painter.set_pen(qt6.new_qcolor6(color))
    end
    painter.draw_text3(x, y, "#{value}")
  end
  return ctx
end
