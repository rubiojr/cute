# Hacker News Reader â€” built with Cute
#
# A native desktop HN client: browse top/new/best/ask/show stories,
# open links in the browser, concurrent fetching, keyboard shortcuts.
#
# Build and run:
#   cd examples/cute_hackernews
#   rugo build main.rugo -o hackernews && ./hackernews
#
# Prerequisites:
#   - Qt6 dev libs (apt install qt6-base-dev)
#   - Go 1.22+

require "./../../" as cute
require "theme"
use "http"
use "json"
use "str"
use "os"
use "cli"

cli.bool_flag("", "light", "l", "Use light theme")
cli.parse()

# -- HN API ------------------------------------------------------------------

PAGE_SIZE = 30

FEED_URLS = {
  top:  "https://hacker-news.firebaseio.com/v0/topstories.json",
  new:  "https://hacker-news.firebaseio.com/v0/newstories.json",
  best: "https://hacker-news.firebaseio.com/v0/beststories.json",
  ask:  "https://hacker-news.firebaseio.com/v0/askstories.json",
  show: "https://hacker-news.firebaseio.com/v0/showstories.json"
}

# Ensure spawn runtime is loaded (needed for spawn inside lambdas)
__boot = spawn nil

def fetch_stories(feed)
  resp = http.get(FEED_URLS[feed])
  ids = json.parse(resp.body)
  ids = ids[0, PAGE_SIZE]

  base = "https://hacker-news.firebaseio.com/v0"
  tasks = []
  for id in ids
    item_url = "#{base}/item/#{id}.json"
    t = spawn http.get(item_url)
    tasks = append(tasks, t)
  end

  stories = []
  for t in tasks
    raw = json.parse(t.value.body)
    if raw != nil
      stories = append(stories, raw)
    end
  end
  return stories
end

def domain(url)
  if url == nil || url == ""
    return ""
  end
  d = url
  if str.contains(d, "://")
    d = str.split(d, "://")[1]
  end
  if str.contains(d, "/")
    d = str.split(d, "/")[0]
  end
  if str.starts_with(d, "www.")
    d = d[4, len(d) - 4]
  end
  return d
end

def open_url(url)
  if url != nil && url != ""
    safe = str.replace(url, "'", "'\\''")
    os.exec("xdg-open '#{safe}' >/dev/null 2>&1 &")
  end
end

# -- Helpers ------------------------------------------------------------------

def story_line(story, index)
  title = story.title
  d = domain(story.url)
  if d != ""
    title = "#{title}  â€”  #{d}"
  end
  points = story.score
  if points == nil
    points = 0
  end
  author = story.by
  if author == nil
    author = "?"
  end
  comments = story.descendants
  if comments == nil
    comments = 0
  end
  return "#{index + 1}.  #{title}\n     â–² #{points}  â€¢  #{author}  â€¢  #{comments} comments"
end

def story_meta(story)
  if story == nil
    return ""
  end
  d = domain(story.url)
  points = story.score
  if points == nil
    points = 0
  end
  author = story.by
  if author == nil
    author = "?"
  end
  comments = story.descendants
  if comments == nil
    comments = 0
  end
  meta = "â–² #{points} points  â€¢  by #{author}  â€¢  #{comments} comments"
  if d != ""
    meta = "#{meta}  â€¢  #{d}"
  end
  return meta
end

def story_url(story)
  if story == nil
    return nil
  end
  url = story.url
  if url == nil || url == ""
    return "https://news.ycombinator.com/item?id=#{story.id}"
  end
  return url
end

def comments_url(story)
  if story == nil
    return nil
  end
  return "https://news.ycombinator.com/item?id=#{story.id}"
end

# -- GUI ----------------------------------------------------------------------

LIGHT_MODE = cli.get("light")

cute.app("Hacker News", 1024, 640) do
  font_size = cute.state(14)

  apply_theme = fn()
    size = font_size.get()
    if LIGHT_MODE
      cute.stylesheet(theme.css(size))
    else
      cute.stylesheet(theme.dark(size))
    end
  end

  apply_theme()

  current_feed = cute.state("top")
  stories = cute.state([])
  story_list = nil
  status = cute.state("Starting...")
  detail_title = nil
  detail_meta = nil

  # -- selected story helpers --

  selected_story = fn()
    row = story_list.current_row()
    items = stories.get()
    if row < 0 || row >= len(items)
      return nil
    end
    return items[row]
  end

  # -- load / reload --

  load = fn(feed)
    current_feed.set(feed)
    status.set("Loading #{feed} stories...")
    stories.set([])

    # Fetch in a background goroutine to keep the UI responsive.
    spawn
      result = fetch_stories(feed)
      cute.ui(fn()
        stories.set(result)
        status.set("#{len(result)} #{feed} stories")
      end)
    end
  end

  # -- build UI ---------------------------------------------------------------

  cute.vbox do

    # Header bar
    header = cute.hbox do
      cute.label("ðŸ”¶  Hacker News", nil, nil)
      cute.spacer()
      cute.combo(["Top", "New", "Best", "Ask", "Show"], fn(text)
        load(str.lower(text))
      end, nil)
      cute.button("â†»  Refresh", nil) do
        load(current_feed.get())
      end
      cute.button("A-", nil) do
        size = font_size.get()
        if size > 8
          font_size.set(size - 1)
          apply_theme()
        end
      end
      cute.button("A+", nil) do
        size = font_size.get()
        if size < 24
          font_size.set(size + 1)
          apply_theme()
        end
      end
    end
    cute.props(header, {margins: [8, 6, 8, 6]})

    # Story list â€” reactive, re-renders when stories state changes
    story_list = cute.list(stories, fn(story, i)
      story_line(story, i)
    end, fn(row)
      s = selected_story()
      if s == nil
        detail_title.set_text("")
        detail_meta.set_text("")
      else
        detail_title.set_text(s.title)
        detail_meta.set_text(story_meta(s))
      end
    end)
    story_list.on_item_double_clicked(fn(item)
      open_url(story_url(selected_story()))
    end)

    # Detail / action bar
    footer = cute.hbox do
      detail_title = cute.label("", nil, nil)
      detail_title.set_maximum_width(400)
      detail_meta = cute.label("", nil, nil)
      detail_meta.set_maximum_width(300)
      cute.spacer()
      cute.button("Open â†—", nil) do
        open_url(story_url(selected_story()))
      end
      cute.button("Comments ðŸ’¬", nil) do
        open_url(comments_url(selected_story()))
      end
    end
    cute.props(footer, {margins: [12, 4, 12, 4]})

    # Status bar â€” auto-bound to reactive state
    cute.label(status, nil, nil)
  end

  # -- keyboard shortcuts --
  cute.shortcut("Ctrl+Q", fn() cute.quit() end)
  cute.shortcut("Ctrl+R", fn() load(current_feed.get()) end)
  cute.shortcut("Return", fn() open_url(story_url(selected_story())) end)
  cute.shortcut("Ctrl+Return", fn() open_url(comments_url(selected_story())) end)
  cute.shortcut("Ctrl++", fn()
    size = font_size.get()
    if size < 24
      font_size.set(size + 1)
      apply_theme()
    end
  end)
  cute.shortcut("Ctrl+-", fn()
    size = font_size.get()
    if size > 8
      font_size.set(size - 1)
      apply_theme()
    end
  end)
  cute.shortcut("Ctrl+0", fn()
    font_size.set(14)
    apply_theme()
  end)

  # -- initial load after window appears --
  cute.after(50, fn()
    load("top")
    story_list.set_current_row(0)
  end)
end
