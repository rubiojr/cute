#!/usr/bin/env rugo
# Run visual tests in Docker for consistent, reproducible results.
#
# Usage:
#   rugo run scripts/test-docker.rugo                  # run all visual tests
#   rugo run scripts/test-docker.rugo counter           # run a specific test
#   rugo run scripts/test-docker.rugo update            # regenerate reference images
#   rugo run scripts/test-docker.rugo counter update    # update a single test
#
# The Docker image pins Fedora 43, Qt6, Go 1.26.0, and font versions
# so reference images are portable across developer machines and CI.
#
# Named volumes persist Go build and rugo module caches across runs.

use "os"
use "str"

# -- Parse arguments ----------------------------------------------------------

update = false
test_name = ""

for arg in os.args()
  update = true if arg == "update"
  test_name = arg if arg != "update"
end

# -- Configuration ------------------------------------------------------------

IMAGE = "cute-test"
DOCKER_DIR = "tests/docker"
CACHE = "cute-test-gocache"

# -- Build Docker image -------------------------------------------------------

puts "Building test image..."
try `docker build -q -t #{IMAGE} #{DOCKER_DIR} 2>/dev/null` or err
  `DOCKER_BUILDKIT=0 docker build -q -t #{IMAGE} #{DOCKER_DIR}`
end

# -- Run tests in container ---------------------------------------------------

update_flag = update && "1"

vol = "-v $PWD:/cute -v #{CACHE}:/root/.cache/go-build -v #{CACHE}-mod:/root/go/pkg/mod -v #{CACHE}-rugo:/root/.rugo"
env = "-e CUTE_TEST_UPDATE=#{update_flag}"

if test_name != ""
  inner = "cd /cute/tests/visual/#{test_name} && rugo build main.rugo -o #{test_name}_test && ./#{test_name}_test; rm -f #{test_name}_test"
  out = try `docker run --rm #{vol} #{env} #{IMAGE} bash -c '#{inner}'` or err
    os.exit(1)
  end
  puts out
else
  update_arg = "update" if update
  out = try `docker run --rm #{vol} #{env} #{IMAGE} bash -c 'rugo run /cute/tests/visual/run.rugo #{update_arg}'` or err
    os.exit(1)
  end
  puts out
end
